{
  "选择题": [
    {
      "question": "算法可以用自然语言、流程图或伪代码描述，但必须具备的特征是（   ）",
      "options": [
        "A. 美观",
        "B. 有穷性与确定性",
        "C. 使用英文",
        "D. 必须包含递归"
      ],
      "answer": "B"
    },
    {
      "question": "若某算法运行时间随输入规模 n 呈线性增长，其时间复杂度记为（   ）",
      "options": [
        "A. O(1)",
        "B. O(log n)",
        "C. O(n)",
        "D. O(n²)"
      ],
      "answer": "C"
    },
    {
      "question": "对长度为 n 的顺序表执行顺序查找，最坏比较次数为（   ）",
      "options": [
        "A. 1",
        "B. log₂n",
        "C. n",
        "D. n²"
      ],
      "answer": "C"
    },
    {
      "question": "若算法空间复杂度为 O(1)，说明它（   ）",
      "options": [
        "A. 不使用任何变量",
        "B. 额外空间与输入规模无关且为常量级",
        "C. 必须原地排序",
        "D. 只能处理常数规模输入"
      ],
      "answer": "B"
    },
    {
      "question": "下列关于穷举法的描述，正确的是（   ）",
      "options": [
        "A. 只适用于排序问题",
        "B. 不需要任何循环语句",
        "C. 逐个尝试所有可能解",
        "D. 一定比递归算法快"
      ],
      "answer": "C"
    },
    {
      "question": "Python伪代码里的“＃”通常表示（ ）",
      "options": [
        "A. 除法运算",
        "B. 注释说明",
        "C. 逻辑或",
        "D. 循环开始"
      ],
      "answer": "B"
    },
    {
      "question": "算法最坏情况时间复杂度是指（   ）",
      "options": [
        "A. 所有输入中运行时间最长的那一类",
        "B. 平均运行时间",
        "C. 最优运行时间",
        "D. 编译时间"
      ],
      "answer": "A"
    },
    {
      "question": "递归模型必须包含的两个部分是（   ）",
      "options": [
        "A. 循环体和终止条件",
        "B. 递归出口和递归体",
        "C. 分治和合并",
        "D. 初始值和增量"
      ],
      "answer": "B"
    },
    {
      "question": "以下哪项不是算法的核心基本特性？（   ）",
      "options": [
        "A.有穷性（执行步骤有限）",
        "B. 确定性（每一步操作唯一且明确）",
        "C. 随机性（可随机选择执行步骤）",
        "D. 可行性（每一步操作可通过有限次实现）"
      ],
      "answer": "C"
    },
    {
      "question": "在 Python 中，执行如下代码的时间复杂度是？（ ） n = 100 for i in range(n): print(i)",
      "options": [
        "A.O(1)",
        "B. O(n)",
        "C. O(n²)",
        "D. O(logn)"
      ],
      "answer": "B"
    },
    {
      "question": "关于线性查找（顺序查找），描述正确的是？（ ）",
      "options": [
        "A.要求查找的列表必须是有序的",
        "B. 从列表第一个元素开始逐个比较，直到找到目标或遍历结束",
        "C. 时间复杂度为 O (logn)",
        "D. 无论数据规模多大，效率都高于二分查找"
      ],
      "answer": "B"
    },
    {
      "question": "算法的空间复杂度主要衡量的是？（ ）",
      "options": [
        "A. 算法执行消耗的时间长短",
        "B. 算法执行过程中占用的存储空间大小",
        "C. 算法的代码行数多少",
        "D. 算法输入数据的数量"
      ],
      "answer": "B"
    },
    {
      "question": "递归算法必须包含的核心要素是？（ ）",
      "options": [
        "A. 循环结构和分支结构",
        "B. 递归终止条件和递归调用（递归体）",
        "C. 多个函数嵌套调用",
        "D. 全局变量的使用"
      ],
      "answer": "B"
    },
    {
      "question": "冒泡排序（升序）的基本操作中，每一轮遍历列表时，对相邻元素的处理规则是？（ ）",
      "options": [
        "A. 只要相邻就交换",
        "B. 若前一个元素大于后一个元素，则交换",
        "C. 随机交换相邻元素",
        "D. 直接将最大元素放到列表末尾（无需逐次交换）"
      ],
      "answer": "B"
    },
    {
      "question": "算法设计的三种基本控制结构不包括？（ ）",
      "options": [
        "A. 顺序结构（按顺序执行步骤",
        "B. 选择结构（分支结构，如 if-else）",
        "C. 循环结构（如 for/while）",
        "D. 递归结构"
      ],
      "answer": "D"
    },
    {
      "question": "分析如下 Python 代码的时间复杂度，正确的是？（ ） n = 50 for i in range(n): for j in range(n): print(i + j)",
      "options": [
        "A. O(n)",
        "B. O(n²)",
        "C. O(logn)",
        "D. O(1)"
      ],
      "answer": "B"
    },
    {
      "question": "回溯法在问题的解空间树中按(     )策略从根结点出发搜索解空间树。",
      "options": [
        "A.广度优先",
        "B.活结点优先",
        "C.扩展结点优先",
        "D.深度优先"
      ],
      "answer": "D"
    },
    {
      "question": "关于回溯法以下叙述中不正确的是(   ) 。",
      "options": [
        "A.回溯法有“通用解题法”之称,它可以系统地搜索一个问题的所有解或任意解",
        "B.回溯法是一种既带系统性又带跳跃性的搜索算法",
        "C.回溯算法需要借助队列这种结构来保存从根结点到当前扩展结点的路径",
        "D.回溯算法在生成解空间的任一结点时先判断该结点是否可能包含问题的解,如果肯定不包含,则跳过对该结点为根的子树的搜索,逐层向祖先结点回溯"
      ],
      "answer": "C"
    },
    {
      "question": "3.回溯法的效率不依赖于下列(   )。",
      "options": [
        "A.确定解空间的时间",
        "B.满足显式约束的值的个数",
        "C.计算限界函数的时间",
        "D.计算约束函数的时间"
      ],
      "answer": "A"
    },
    {
      "question": "下面(   )是回溯法中为避免无效搜索采取的策略。",
      "options": [
        "A.递归函数",
        "B.剪枝函数",
        "C.随机数函数",
        "D.搜索函数"
      ],
      "answer": "B"
    },
    {
      "question": "分枝限界法在问题的解空间树中按(   )策略从根结点出发搜索解空间树。",
      "options": [
        "A.广度优先",
        "B.活结点优先",
        "C.扩展结点优先",
        "D.深度优先"
      ],
      "answer": "A"
    },
    {
      "question": "常见的两种分枝限界法为(   )。",
      "options": [
        "A.广度优先分枝限界法与深度优先分枝限界法",
        "B.队列式(FIFO)分枝限界法与堆栈式分枝限界法",
        "C.排列树法与子集树法",
        "D.队列式(FIFO)分枝限界法与优先队列式分枝限界法"
      ],
      "answer": "D"
    },
    {
      "question": "7.在用分枝限界法求解0/1背包问题时活结点表的组织形式是(    )。",
      "options": [
        "A.小根堆",
        "B.大根堆",
        "C.栈",
        "D.数组"
      ],
      "answer": "B"
    },
    {
      "question": "下列采用最大效益优先搜索方式的算法是(   )。",
      "options": [
        "A.分枝界限法",
        "B.动态规划法",
        "C.贪心法",
        "D. 回溯法"
      ],
      "answer": "A"
    },
    {
      "question": "设算法的时间复杂度递归式为 T (n)=4T (n/2)+O (n)，其中 n 为问题规模且 n 是 2 的幂，根据主定理，该算法的时间复杂度为（  ）",
      "options": [
        "A. O (n)",
        "B. O (nlogn)",
        "C. O (n²)",
        "D. O (2ⁿ)"
      ],
      "answer": "C"
    },
    {
      "question": "关于分治法的适用条件，下列说法错误的是（  ）",
      "options": [
        "A. 问题可以分解为若干个规模较小的相同子问题",
        "B. 子问题的解可以合并为原问题的解",
        "C. 子问题之间必须存在依赖关系，才能保证合并的正确性",
        "D. 子问题可以独立求解，无需依赖其他子问题的结果"
      ],
      "answer": "C"
    },
    {
      "question": "动态规划算法的核心是利用 “最优子结构” 和 “重叠子问题” 特性，下列问题中不适合用动态规划求解的是（  ）",
      "options": [
        "A. 0-1 背包问题",
        "B. 最长公共子序列（LCS）问题",
        "C. 最大子段和问题",
        "D. 快速排序问题"
      ],
      "answer": "D"
    },
    {
      "question": "贪心算法求解活动安排问题时，选择活动的贪心策略是优先选择（  ）的活动，以最大化相容活动数量",
      "options": [
        "A. 开始时间最早",
        "B. 结束时间最早",
        "C. 持续时间最短",
        "D. 开始时间最晚"
      ],
      "answer": "B"
    },
    {
      "question": "回溯法解 0-1 背包问题时，若物品按单位重量价值从大到小排序，剪枝函数不包括（  ）",
      "options": [
        "A. 约束剪枝：当前总重量超过背包容量则剪枝",
        "B. 限界剪枝：当前价值 + 剩余物品的最大可能价值 ≤ 当前最优解则剪枝",
        "C. 优化剪枝：当前物品数量超过背包容量则剪枝",
        "D. 以上均是剪枝函数"
      ],
      "answer": "C"
    },
    {
      "question": "已知某算法的时间复杂度为 T (n)=O (n³)，空间复杂度为 S (n)=O (n)，当问题规模 n 扩大为原来的 2 倍时，该算法的时间开销约扩大为原来的（  ）",
      "options": [
        "A. 2 倍",
        "B. 4 倍",
        "C. 8 倍",
        "D. 16 倍"
      ],
      "answer": "C"
    },
    {
      "question": "关于 Floyd-Warshall 算法求解多源最短路径问题，下列说法正确的是（  ）",
      "options": [
        "A. 算法基于贪心策略，时间复杂度为 O (n²)",
        "B. 算法基于动态规划策略，时间复杂度为 O (n³)",
        "C. 算法适用于带负权边但无负权回路的图",
        "D. B 和 C 均正确"
      ],
      "answer": "D"
    },
    {
      "question": "分支限界法与回溯法的本质区别不包括（  ）",
      "options": [
        "A. 搜索方式：回溯法是深度优先，分支限界法是广度优先",
        "B. 存储结构：回溯法常用栈，分支限界法常用队列或优先队列",
        "C. 求解目标：回溯法求所有解，分支限界法求最优解",
        "D. 剪枝策略：回溯法无剪枝，分支限界法依赖剪枝函数"
      ],
      "answer": "D"
    },
    {
      "question": "设数组 A [1..n] 采用二路归并排序，其空间复杂度为（  ）",
      "options": [
        "A. O (1)",
        "B. O (logn)",
        "C. O (n)",
        "D. O (nlogn)"
      ],
      "answer": "C"
    },
    {
      "question": "关于 NP 完全问题，下列描述正确的是（  ）",
      "options": [
        "A. NP 完全问题是 NP 问题中最难的一类，目前没有多项式时间算法",
        "B. 若一个 NP 完全问题存在多项式时间算法，则所有 NP 问题都存在多项式时间算法",
        "C. 旅行商问题（TSP）是典型的 NP 完全问题",
        "D. A、B、C 均正确"
      ],
      "answer": "D"
    },
    {
      "question": "算法的 5 个重要特性不包括以下哪一项？（  ）",
      "options": [
        "A. 有穷性",
        "B. 确定性",
        "C. 可行性",
        "D. 复杂性"
      ],
      "answer": "D"
    },
    {
      "question": "以下哪种排序算法的最坏时间复杂度为 O()？（  ）",
      "options": [
        "A. 归并排序",
        "B. 快速排序",
        "C. 冒泡排序",
        "D. 堆排序"
      ],
      "answer": "C"
    },
    {
      "question": "分治法的基本步骤不包含下列哪个环节？（）",
      "options": [
        "A. 分解",
        "B. 解决",
        "C. 合并",
        "D. 迭代"
      ],
      "answer": "D"
    },
    {
      "question": "动态规划算法的核心是利用（  ）避免重复计算子问题。",
      "options": [
        "A. 贪心选择性质",
        "B. 最优子结构",
        "C. 备忘录",
        "D. 递归"
      ],
      "answer": "B"
    },
    {
      "question": "贪心算法求解最优问题的关键是要满足（）。",
      "options": [
        "A. 最优子结构",
        "B. 贪心选择性质",
        "C. 重叠子问题",
        "D. 无后效性"
      ],
      "answer": "B"
    },
    {
      "question": "以下属于 NP 难问题的是？（）",
      "options": [
        "A. 线性规划问题",
        "B. 哈夫曼编码问题",
        "C. 旅行商问题（TSP）",
        "D. 二分查找问题"
      ],
      "answer": "C"
    },
    {
      "question": "二分查找算法的时间复杂度为（）。",
      "options": [
        "A. O(n)",
        "B. O()",
        "C. O(n)",
        "D. O()"
      ],
      "answer": "B"
    },
    {
      "question": "用于求解单源最短路径问题的经典算法是（）。",
      "options": [
        "A. Floyd 算法",
        "B. Prim 算法",
        "C. Dijkstra 算法",
        "D. Kruskal 算法"
      ],
      "answer": "C"
    },
    {
      "question": "算法的时间复杂度取决于（）",
      "options": [
        "A. 问题的规模",
        "B. 计算机的配置",
        "C. 编程语言",
        "D. 算法的代码行数"
      ],
      "answer": "A"
    },
    {
      "question": "采用递归方式实现斐波那契数列，其时间复杂度为（）",
      "options": [
        "A.O(n)",
        "B.O(n)",
        "C.O(2ⁿ)",
        "D.O()"
      ],
      "answer": "C"
    },
    {
      "question": "对于一个长度为 n 的有序数组，二分查找的最坏时间复杂度是（）",
      "options": [
        "A.O(n)",
        "B.O()",
        "C.O(n)",
        "D.O()"
      ],
      "answer": "B"
    },
    {
      "question": "以下排序算法中，不稳定的是（ ）",
      "options": [
        "A.冒泡排序",
        "B.插入排序",
        "C.快速排序",
        "D.归并排序"
      ],
      "answer": "C"
    },
    {
      "question": "动态规划算法的核心是避免重复计算，其实现的关键是（ ）",
      "options": [
        "A.定义状态",
        "B.确定递归公式",
        "C.存储中间状态",
        "D.以上都是"
      ],
      "answer": "D"
    },
    {
      "question": "贪心算法求解活动安排问题时，选择的贪心策略是（ ）",
      "options": [
        "A.最早开始时间优先",
        "B.最晚开始时间优先",
        "C.最早结束时间优先",
        "D.持续时间最短优先"
      ],
      "answer": "C"
    },
    {
      "question": "深度优先搜索（DFS）通常采用的数据结构是（）",
      "options": [
        "A.队列",
        "B.栈",
        "C.哈希表",
        "D.优先队列"
      ],
      "answer": "B"
    },
    {
      "question": "Dijkstra 算法用于求解单源最短路径问题，其时间复杂度可以通过（）优化至 O((n+e)\\log_2 n)（n 为顶点数，e 为边数）",
      "options": [
        "A.普通队列",
        "B.栈",
        "C.优先队列（堆）",
        "D.哈希表"
      ],
      "answer": "C"
    },
    {
      "question": "对于一个具有 n 个顶点的无向完全图，其生成树的边数为（）",
      "options": [
        "A. n-1",
        "B. n",
        "C.n(n-1)/2",
        "D.n(n+1)/2"
      ],
      "answer": "A"
    },
    {
      "question": "哈希表的查找效率主要取决于（）",
      "options": [
        "A.哈希函数",
        "B.处理冲突的方法",
        "C.装填因子",
        "D.以上都是"
      ],
      "answer": "D"
    },
    {
      "question": "算法的基本特征不包括：()",
      "options": [
        "A. 有穷性",
        "B. 确定性",
        "C. 能行性",
        "D. 可移植性"
      ],
      "answer": "D"
    },
    {
      "question": "时间复杂度主要衡量的是：(  )",
      "options": [
        "A. 算法占用内存的大小",
        "B. 算法执行时间的增长率",
        "C. 算法代码的长度",
        "D. 算法输入数据的规模"
      ],
      "answer": "B"
    },
    {
      "question": "递归算法的特点是：(  )",
      "options": [
        "A. 必须使用循环结构",
        "B. 函数调用自身",
        "C. 只能有一个参数",
        "D. 不能有返回值"
      ],
      "answer": "B"
    },
    {
      "question": "分治法的基本步骤是：(  )",
      "options": [
        "A. 分解、解决、合并",
        "B. 选择、交换、合并",
        "C. 迭代、递归、回溯",
        "D. 输入、处理、输出"
      ],
      "answer": "A"
    },
    {
      "question": "贪心算法的特点是：(  )",
      "options": [
        "A. 总是得到全局最优解",
        "B. 每一步做出当前最优选择",
        "C. 必须使用动态规划",
        "D. 适用于所有优化问题"
      ],
      "answer": "B"
    },
    {
      "question": "回溯法通常用于解决：(  )",
      "options": [
        "A. 数值计算问题",
        "B. 最短路问题",
        "C. 组合优化问题",
        "D. 排序问题"
      ],
      "answer": "C"
    },
    {
      "question": "算法分析的两个主要方面是：(  )",
      "options": [
        "A. 时间复杂度和空间复杂度",
        "B. 正确性和可读性",
        "C. 健壮性和可维护性",
        "D. 输入和输出规模"
      ],
      "answer": "A"
    },
    {
      "question": "动态规划的基本性质是：(  )",
      "options": [
        "A. 自顶向下求解",
        "B. 适用于所有递归问题",
        "C. 具有最优子结构",
        "D. 必须使用贪心策略"
      ],
      "answer": "C"
    },
    {
      "question": "二分搜索算法虽然高效，但它对数据的存储结构和排列方式有严格要求。以下哪种情况最适合直接使用二分搜索？(  ) A、存储在单链表中的有序序列 B、存储在顺序表（数组）中的无序序列 C、存储在顺序表（数组）中的有序序列 D、存储在二叉排序树中的节点",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "C"
    },
    {
      "question": "在算法分析中，我们通常用“大O”符号（如 $O(N)$）来表示算法的时间复杂度。它具体描述的是算法运行时间的： A、最好情况下的下界 B、平均情况下的运行时间 C、最坏情况下的渐进上界 D、每一行代码执行的确切次数",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "C"
    },
    {
      "question": "若需要对100个不同的字符进行哈夫曼编码，构建出的哈夫曼树中，总共包含多少个结点？ A、100 B、199 C、200 D、201",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "B"
    },
    {
      "question": "设元素的进栈顺序是1、2、3。若要得到出栈顺序为2、3、1，则相应的S（进栈）和X（出栈）操作序列是： A、SXSSXX B、SSXSXX C、SSXXSX D、SXSSXS",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "B"
    },
    {
      "question": "动态规划法与分治法最大的区别在于： A、动态规划不需要递归 B、动态规划分解出的子问题是相互重叠的 C、动态规划只能解决优化问题 D、分治法的效率总是比动态规划高",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "B"
    },
    {
      "question": "若一个栈的输入序列是1,2,3,4。以下哪一个出栈序列是不可能出现的？ A、1,2,3,4 B、2,4,1,3 C、3,2,4,1 D、3,4,2,1",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "B"
    },
    {
      "question": "下列算法中，通常采用广度优先搜索（BFS）或最小耗费优先策略在解空间树中搜索目标的是： A、回溯法 B、分支限界法 C、动态规划法 D、贪心法",
      "options": [
        "选项A",
        "选项B",
        "选项C",
        "选项D"
      ],
      "answer": "B"
    },
    {
      "question": "下列算法策略中，核心是 “将大问题拆分为独立子问题，合并子问题解” 的是（ ）",
      "options": [
        "A. 贪心法",
        "B. 分治法",
        "C. 回溯法",
        "D. 分支限界法"
      ],
      "answer": "B"
    },
    {
      "question": "算法的时间复杂度用来描述（ ）",
      "options": [
        "A. 算法的代码长度",
        "B. 算法执行所需的时间与输入规模的关系",
        "C. 算法占用的存储空间",
        "D. 算法的调试难度"
      ],
      "answer": "B"
    },
    {
      "question": "下列数据结构中，适合实现 “先进先出” 逻辑的是（ ）",
      "options": [
        "A. 栈",
        "B. 队列",
        "C. 二叉搜索树",
        "D. 堆"
      ],
      "answer": "B"
    },
    {
      "question": "动态规划算法之所以能提高效率，关键是利用了（ ）性质避免重复计算",
      "options": [
        "A. 贪心选择",
        "B. 最优子结构",
        "C. 重叠子问题",
        "D. 随机选择"
      ],
      "answer": "C"
    },
    {
      "question": "二分查找算法的前提条件是（ ）",
      "options": [
        "A. 数组无序",
        "B. 数组元素不重复",
        "C. 数组已排序",
        "D. 数组长度为偶数"
      ],
      "answer": "C"
    },
    {
      "question": "下列问题中，最适合用贪心法求解的是（ ）",
      "options": [
        "A. 0-1 背包问题",
        "B. 最短路径问题（边权相等）",
        "C. 最长公共子序列问题",
        "D. 迷宫寻路问题"
      ],
      "answer": "B"
    },
    {
      "question": "回溯法在搜索解空间树时，若发现当前路径无法得到最优解，会采取（ ）策略",
      "options": [
        "A. 继续深入搜索",
        "B. 回溯到上一节点",
        "C. 直接终止程序",
        "D. 随机选择下一路径"
      ],
      "answer": "B"
    },
    {
      "question": "函数 T (n) = 3n + 5 的时间复杂度表示为（ ）",
      "options": [
        "A. O (1)",
        "B. O (n)",
        "C. O (n²)",
        "D. O (log n)"
      ],
      "answer": "B"
    },
    {
      "question": "分支限界法与回溯法的核心区别在于（ ）",
      "options": [
        "A. 是否需要解空间树",
        "B. 搜索方式和求解目标不同",
        "C. 是否使用递归实现",
        "D. 是否适用于组合优化问题"
      ],
      "answer": "B"
    },
    {
      "question": "下列算法中，依赖 “贪心选择性质” 才能得到最优解的是（ ）",
      "options": [
        "A. 归并排序",
        "B. 哈夫曼编码",
        "C. 弗洛伊德最短路径算法",
        "D. 快速排序"
      ],
      "answer": "B"
    },
    {
      "question": "递归算法的基本要素不包括（ ）",
      "options": [
        "A. 递归出口",
        "B. 递归调用",
        "C. 子问题规模递减",
        "D. 非递归实现方式"
      ],
      "answer": "D"
    },
    {
      "question": "若一个算法的时间复杂度为 O (n log n)，则当输入规模 n 翻倍时，算法执行时间大致会（ ）",
      "options": [
        "A. 翻倍",
        "B. 变为原来的 2log2 倍",
        "C. 变为原来的 4 倍",
        "D. 不变"
      ],
      "answer": "B"
    },
    {
      "question": "下列关于 “算法” 的描述中，最准确的是（ ）",
      "options": [
        "A. 算法是编写程序的语言",
        "B. 算法是解决问题的有限步骤集合，且必须有输出",
        "C. 算法只能用 Python 语言实现",
        "D. 算法不需要考虑时间和空间开销"
      ],
      "answer": "B"
    },
    {
      "question": "算法时间复杂度的表示中，O (n) 表示的是（ ）",
      "options": [
        "A. 算法执行时间与输入规模 n 无关",
        "B. 算法执行时间与输入规模 n 成线性关系",
        "C. 算法执行时间与输入规模 n 的平方成正比",
        "D. 算法执行时间随 n 增长呈指数增长"
      ],
      "answer": "B"
    },
    {
      "question": "冒泡排序算法的核心操作是（ ）",
      "options": [
        "A. 选择数组中最小的元素放到最前面",
        "B. 将相邻元素两两比较，逆序则交换",
        "C. 把元素插入到已排序序列的合适位置",
        "D. 递归拆分数组后合并排序"
      ],
      "answer": "B"
    },
    {
      "question": "下列哪种算法思想最适合解决 “求 n 的阶乘” 问题（n 为正整数）？（ ）",
      "options": [
        "A. 贪心算法",
        "B. 递归算法",
        "C. 分治算法",
        "D. 动态规划算法"
      ],
      "answer": "B"
    },
    {
      "question": "贪心算法的基本思路是（ ）",
      "options": [
        "A. 把问题拆分成多个子问题，逐个解决后合并结果",
        "B. 每次选择当前最优解，逐步推导全局最优解",
        "C. 存储子问题结果，避免重复计算",
        "D. 随机选择解决方案，逐步优化"
      ],
      "answer": "B"
    },
    {
      "question": "插入排序算法在什么情况下时间复杂度最优？（ ）",
      "options": [
        "A. 输入数组完全逆序",
        "B. 输入数组已经有序",
        "C. 输入数组元素随机排列",
        "D. 输入数组元素全相同"
      ],
      "answer": "B"
    },
    {
      "question": "算法分析的主要目的是（ ）",
      "options": [
        "A. 检查算法是否正确",
        "B. 评估算法的执行效率和资源占用",
        "C. 优化算法的代码格式",
        "D. 确保算法能在所有编程语言中实现"
      ],
      "answer": "B"
    },
    {
      "question": "下列问题中，最适合用动态规划算法解决的是（ ）",
      "options": [
        "A. 查找数组中的最大值",
        "B. 斐波那契数列第 n 项计算",
        "C. 简单的线性查找",
        "D. 快速排序"
      ],
      "answer": "B"
    },
    {
      "question": "以下哪种排序算法在最坏情况下的时间复杂度是 O(n²)？ (  )",
      "options": [
        "A. 归并排序",
        "B. 快速排序",
        "C. 堆排序",
        "D. 计数排序"
      ],
      "answer": "B"
    },
    {
      "question": "在二叉搜索树中，查找一个关键字的时间复杂度是： (  )",
      "options": [
        "A. O(n)",
        "B. O(log n)",
        "C. O(n log n)",
        "D. 与树的结构有关，最坏情况下为 O(n)"
      ],
      "answer": "D"
    },
    {
      "question": "关于 NP 问题，以下说法正确的是： (  )",
      "options": [
        "A. NP 问题是指可以在多项式时间内解决的问题",
        "B. NP 问题是指可以在多项式时间内验证一个解的问题",
        "C. NP 问题一定是 P 问题",
        "D. NP 问题一定不能在多项式时间内解决"
      ],
      "answer": "B"
    },
    {
      "question": "使用动态规划解决问题时，通常具有： (  )",
      "options": [
        "A. 重叠子问题和最优子结构",
        "B. 分治思想和递归求解",
        "C. 贪心选择性质",
        "D. 随机化选择"
      ],
      "answer": "A"
    },
    {
      "question": "一个算法的时间复杂度为 O(n³)，当输入规模增大一倍时，运行时间大约会： (  )",
      "options": [
        "A. 增加 2 倍",
        "B. 增加 4 倍",
        "C. 增加 8 倍",
        "D. 增加 16 倍"
      ],
      "answer": "C"
    },
    {
      "question": "以下哪种数据结构支持先进先出（FIFO）(  )？",
      "options": [
        "A. 栈",
        "B. 队列",
        "C. 堆",
        "D. 优先队列"
      ],
      "answer": "B"
    },
    {
      "question": "对于长度为 n 的数组，插入排序的平均时间复杂度是：(  )",
      "options": [
        "A. O(n)",
        "B. O(n log n)",
        "C. O(n²)",
        "D. O(log n)"
      ],
      "answer": "C"
    },
    {
      "question": "在分治策略中，将问题分解为子问题，然后合并子问题的解。以下哪个算法使用了分治策略？(  )",
      "options": [
        "A. 冒泡排序",
        "B. 选择排序",
        "C. 归并排序",
        "D. 插入排序"
      ],
      "answer": "C"
    },
    {
      "question": "关于算法时间复杂度的描述，以下哪项是正确的 (  )？",
      "options": [
        "A.时间复杂度只关心最坏情况下的运行时间",
        "B.大O表示法描述的是算法运行时间的上界",
        "C.常数项在时间复杂度分析中非常重要",
        "D.空间复杂度比时间复杂度更重要"
      ],
      "answer": "B"
    },
    {
      "question": "快速排序的平均时间复杂度是：  (  )",
      "options": [
        "A.O(n²)",
        "B.O(n log n)",
        "C.O(log n)",
        "D.O(n!)"
      ],
      "answer": "B"
    },
    {
      "question": "二分查找算法适用的前提条件是：  (  )",
      "options": [
        "A.数据存储在链表中",
        "B.数据量小于1000个",
        "C.数据已经排序",
        "D.数据都是整数"
      ],
      "answer": "C"
    },
    {
      "question": "以下哪种排序算法是稳定的？  (  )",
      "options": [
        "A.快速排序",
        "B.堆排序",
        "C.选择排序",
        "D.归并排序"
      ],
      "answer": "D"
    },
    {
      "question": "在一个有n个顶点的图中，深度优先搜索(DFS)的时间复杂度是：  (  )",
      "options": [
        "A.O(n)",
        "B.O(n²)",
        "C.O(n log n)",
        "D.O(2n)"
      ],
      "answer": "B"
    },
    {
      "question": "以下哪种数据结构是\"先进先出\"(FIFO)的？  (  )",
      "options": [
        "A.栈",
        "B.队列",
        "C.堆",
        "D.树"
      ],
      "answer": "B"
    },
    {
      "question": "哈希表的主要优点是什么？  (  )",
      "options": [
        "A.总是保持数据有序",
        "B.平均情况下的查找时间为O(1)",
        "C.不需要处理冲突",
        "D.空间利用率最高"
      ],
      "answer": "B"
    },
    {
      "question": "如果一个算法的时间复杂度是O(2ⁿ)，这意味着：  (  )",
      "options": [
        "A.算法效率很高",
        "B.算法只适用于小规模问题",
        "C.算法是多项式时间算法",
        "D.算法总是能找到最优解"
      ],
      "answer": "B"
    }
  ],
  "填空题": [
    {
      "question": "算法的五大基本特性包括：输入、输出、有穷性、确定性和________。",
      "answer": "可行性"
    },
    {
      "question": "时间复杂度是指算法执行所需________的量级，用于衡量算法的时间效率。",
      "answer": "时间"
    },
    {
      "question": "空间复杂度是指算法执行过程中所需________的量级，用于衡量算法的空间效率。",
      "answer": "存储空间"
    },
    {
      "question": "冒泡排序的平均时间复杂度为________，是一种稳定的排序算法。",
      "answer": "O(n²)"
    },
    {
      "question": "二分查找的前提条件是待查找的数组必须是________的，其时间复杂度为 O (log n)。",
      "answer": "有序（或 “排好序”）"
    },
    {
      "question": "贪心算法的核心思想是在每一步选择中都采取当前状态下________的选择，以期望最终得到全局最优解。",
      "answer": "最优（或 “局部最优”）"
    },
    {
      "question": "动态规划算法通过将问题分解为________子问题，并存储子问题的解来避免重复计算。",
      "answer": "重叠子问题（或 “子问题重叠”）"
    },
    {
      "question": "递归算法的执行过程包括________和回溯两个阶段。",
      "answer": "递推（或 “递归调用”）"
    },
    {
      "question": "在顺序存储的线性表中，删除第i个元素（1≤i≤n）需要从后向前移动________个元素。",
      "answer": "n-i"
    },
    {
      "question": "在一个单链表中，若要在指针p所指向的结点之后插入一个新结点，则需要修改________个指针。",
      "answer": "2"
    },
    {
      "question": "栈是一种具有 ________ 特性的线性表。",
      "answer": "后进先出（LIFO）"
    },
    {
      "question": "队列的插入操作在________进行，删除操作在________进行。",
      "answer": "队尾 队头"
    },
    {
      "question": "在二叉树中，第i层（i≥1）最多有________个结点。",
      "answer": ""
    },
    {
      "question": "图的深度优先搜索遍历算法通常使用________数据结构来实现。",
      "answer": "栈"
    },
    {
      "question": "对n个元素进行快速排序，最坏情况下的时间复杂度为________。",
      "answer": "O(n²)"
    },
    {
      "question": "在有序表（2,5,7,10,14,15,18,23,35,41,52）中，用二分查找法查找关键码15，需要比较________次。",
      "answer": "1"
    },
    {
      "question": "在用穷举法解题时，针对穷举对象的数据类型和解的特性可以采用不同的列举方法，如顺序列举，_________，组合列举",
      "answer": "排序列举"
    },
    {
      "question": "贪心法_______（能/不能）解决0-1背包问题",
      "answer": "不能"
    },
    {
      "question": "栈的入栈和出栈的顺序规律是_______",
      "answer": "先进后出"
    },
    {
      "question": "回溯法存储结点的数据结构是_______.",
      "answer": "栈"
    },
    {
      "question": "动态规划求解问题一般要具有3个性质：最优子结构性质，__________，重叠子问题。",
      "answer": "无后效性"
    },
    {
      "question": "算法的三要素：操作、控制结构、__________",
      "answer": "数据结构"
    },
    {
      "question": "算法分析的两个主要方面是__________和空间复杂度的分析。",
      "answer": "时间复杂度"
    },
    {
      "question": "算法复杂性从实际计算机中抽取出来,只依赖于问题的规模、算法的输入和________.",
      "answer": "算法本身"
    },
    {
      "question": "算法具有以下五个重要特性：________，确定性，________，输入，输出。",
      "answer": "有穷性 可行性"
    },
    {
      "question": "算法设计应该要满足以下要求：正确性，可使用性，可读性，________，________。",
      "answer": "健壮性 高效率与储存量"
    },
    {
      "question": "根据遍历方式的不同，图的遍历方法有两种，分别是 ：________，________。",
      "answer": "深度优先便利 广度优先遍历"
    },
    {
      "question": "在用穷举法解题时，针对穷举对象的数据类型和解的特性，可以采用不同的列举方法，常用的列举方法有：________，________，________。",
      "answer": "顺序列举 排列列举 组合列举"
    },
    {
      "question": "以下递推式的时间复杂度为：________",
      "answer": "O(n²)"
    },
    {
      "question": "所谓回溯法，就是在解空间中采用深度优先搜索方法从 ________ 出发搜索解，与树的遍历类似，当搜索到某个叶子节点时对应一个可能的解，如果同时又满足约束条件，这该可能解是一个________。",
      "answer": "根节点 可行解"
    },
    {
      "question": "分支界限法与回溯法都是在解空间中搜索问题的解，但他们之间对解空间的搜索方式又有所不同，分支界限法采用________，回溯法采用________。",
      "answer": "广度优先搜索  深度度优先搜索"
    },
    {
      "question": "由于贪心法一般不会测试所有可能路径,而且容易过早地做决定,所以有些问题可能不会找到最优解,能够采用贪心法求解的问题一般具有两个性质——________和________。",
      "answer": "最优子结构性质 贪心选择性质"
    },
    {
      "question": "算法的时间复杂度用于描述算法执行所需的__________随问题规模增长的变化趋势，常用大 O 记号表示，例如线性时间复杂度记为__________。",
      "answer": "时间；O(n)"
    },
    {
      "question": "若一个问题可以在多项式时间内求解，则该问题属于__________类问题；NP 问题是指可以在多项式时间内__________解的正确性的问题。",
      "answer": "P；验证"
    },
    {
      "question": "算法的空间复杂度包括程序代码占用的__________空间和运行时动态分配的临时空间。",
      "answer": "固定"
    },
    {
      "question": "算法是解决特定问题的有穷性步骤集合，其三大基本特性包括可行性、确定性和__________。",
      "answer": "有穷性（或 “终止性”）"
    },
    {
      "question": "快速排序的平均时间复杂度为__________。",
      "answer": "O(nlogn)"
    },
    {
      "question": "动态规划算法求解问题的两个核心特性是重叠子问题和__________。",
      "answer": "最优子结构"
    },
    {
      "question": "Prim 算法求解最小生成树时，从单个顶点出发逐步__________边以构建生成树。",
      "answer": "扩展（或 “添加”）"
    },
    {
      "question": "分治算法的基本步骤可概括为分解、求解子问题和__________。",
      "answer": "合并"
    },
    {
      "question": "Python 标准库 math 中用来计算平方根的函数是____。",
      "answer": "sqrt"
    },
    {
      "question": "查看变量类型的 Python 内置函数是____。",
      "answer": "type()"
    },
    {
      "question": "Python 运算符中用来计算集合并集的是____。",
      "answer": "|"
    },
    {
      "question": "已知 x = 3, 那么执行语句 x *= 6 之后，x 的值为______。",
      "answer": "18"
    },
    {
      "question": "已知 x = 3，并且 id(x)的返回值为 496103280, 那么执行语句 x += 6 之后表达式 id(x) == 496103280 的值为_。",
      "answer": "False"
    },
    {
      "question": "表达式 int('123', 8) 的值为______。",
      "answer": "83"
    },
    {
      "question": "已知 a =[1，2，3] 和 b =[1，2，4] ，那么 id(a[1])==id(b[1])的执行结果为_。",
      "answer": "True"
    },
    {
      "question": "______命令既可以删除列表中的一个元素，也可以删除整个列表。",
      "answer": "del"
    },
    {
      "question": "算法分析中，________和________是衡量算法资源消耗的两个核心指标，其中时间复杂度关注算法执行的________随问题规模的变化。",
      "answer": "时间复杂度  空间复杂度  基本操作次数"
    },
    {
      "question": "线性表的两种物理存储结构为________和________，其中链表在插入删除操作时无需移动元素，效率更高。",
      "answer": "顺序存储  链式存储"
    },
    {
      "question": "冒泡排序属于________类排序算法，其一趟遍历的核心是通过________将最大（或最小）元素“浮”到序列末端。",
      "answer": "交换相邻元素   比较交换"
    },
    {
      "question": "分治法的三个基本步骤是________、________和________，归并排序和快速排序是分治法的典型应用。",
      "answer": "分解  解决   合并"
    },
    {
      "question": "回溯法解决问题时通常采用________ 策略遍历解空间树，通过________操作避免无效的搜索路径。",
      "answer": "深度优先搜索（DFS）   剪枝"
    },
    {
      "question": "分枝限界法与回溯法的核心区别在于，前者以________或________的方式搜索解空间，且会为每个节点计算________来判断是否继续扩展。",
      "answer": "广度优先  最小代价优先  界限函数"
    },
    {
      "question": "贪心算法求解最优解的前提是问题具有________和________，哈夫曼编码是贪心算法的经典应用。",
      "answer": "贪心选择性质   最优子结构性质"
    },
    {
      "question": "计算复杂性理论中，________是指能在多项式时间内被确定性算法解决的问题，而________是指能在多项式时间内验证解的正确性的问题。",
      "answer": "P类问题   NP类问题"
    },
    {
      "question": "算法的________是衡量算法执行效率的重要指标，它描述了算法执行时间随输入规模增长的变化趋势。",
      "answer": "时间复杂度"
    },
    {
      "question": "分治法的核心思想是将原问题分解为若干________的子问题，求解子问题后再合并得到原问题的解。",
      "answer": "规模更小"
    },
    {
      "question": "动态规划算法通过存储________来避免重复计算，以此提升算法效率。",
      "answer": "子问题的解"
    },
    {
      "question": "贪心算法在每一步决策中都选择当前状态下的局部最优解，试图通过________得到全局最优。",
      "answer": "局部最优"
    },
    {
      "question": "冒泡排序算法在最好情况下的时间复杂度为________ 。",
      "answer": "O(n)"
    },
    {
      "question": "递归算法的执行过程主要分为递推和________两个阶段。",
      "answer": "回归"
    },
    {
      "question": "一个算法的空间复杂度包括程序代码空间、输入数据空间和________空间三部分。",
      "answer": "辅助"
    },
    {
      "question": "在有序数组中进行查找时，效率最高的算法是________。",
      "answer": "二分查找（折半查找）"
    },
    {
      "question": "一个________是指一系列解决问题的明确指令，对于符合规范的输入，能够在有限步骤内得到输出。",
      "answer": "算法"
    },
    {
      "question": "在渐进符号中，O(g(n)) 表示函数的________界，Ω(g(n))表示函数的________界。",
      "answer": "渐进上（上）  渐进下（下）"
    },
    {
      "question": "分治法的设计思想是将一个难以直接解决的大问题，分割成若干个规模较小的相同问题，然后________解决这些子问题，最后将子问题的解合并得到原问题的解。",
      "answer": "递归地（分别）"
    },
    {
      "question": "在“最大子数组问题”的暴力求解方法中，其时间复杂度是________，而使用分治法可以将其优化至 O(n log n)。",
      "answer": "O(n²)"
    },
    {
      "question": "使用减治法解决问题时，通常只对问题的________实例进行求解，从而降低问题的规模。",
      "answer": "一个（部分）"
    },
    {
      "question": "图的深度优先搜索（DFS）通常借助________数据结构实现，而广度优先搜索（BFS）通常借助队列实现。",
      "answer": "栈"
    },
    {
      "question": "动态规划的两个基本要素是________性质和子问题重叠性质。",
      "answer": "最优子结构"
    },
    {
      "question": "如果一个算法的时间复杂度为O(n²)，随着输入规模n增大，其执行时间将按________增长。",
      "answer": "平方级"
    },
    {
      "question": "算法必须满足的特性包括：输入、输出、________、________和可行性。",
      "answer": "确定性  有穷性"
    },
    {
      "question": "在时间复杂度分析中，若 T(n) = 10n² + 3nlog n ，则其渐进表达式为________。",
      "answer": "O(n²)"
    },
    {
      "question": "分治法的三个基本步骤是：________、解决和________。",
      "answer": "分解  合并"
    },
    {
      "question": "动态规划算法的两个关键性质是________和________。",
      "answer": "最优子结构性质  重叠子问题性质"
    },
    {
      "question": "贪心算法中，通过局部最优选择达到全局最优解的特性称为________。",
      "answer": "贪心选择性质"
    },
    {
      "question": "回溯法中用于剪去无效分支的函数称为________。",
      "answer": "剪枝函数"
    },
    {
      "question": "分支限界法通常采用________实现搜索，常用________遍历方式。",
      "answer": "队列（或优先队列） 广度优先"
    },
    {
      "question": "0/1背包问题________（填“适用”或“不适用”）贪心算法求解，因其不满足贪心选择性质。",
      "answer": "不适用"
    },
    {
      "question": "计算机资源主源主要包括________和________。",
      "answer": "计算时间   内存空间"
    },
    {
      "question": "一个算法的存储量包括________、________。",
      "answer": "输入数据所占空间    辅助变量所占空间"
    },
    {
      "question": "图的遍历的方法：________、________。",
      "answer": "深度优化遍历   广度优先遍历"
    },
    {
      "question": "栈具有________的特点。",
      "answer": "后进先出"
    },
    {
      "question": "递归算法是指________。",
      "answer": "在算法定义中又调用自身的算法"
    },
    {
      "question": "求解问题分为两种类型：________、________。",
      "answer": "所有可行解类型  最优解类型"
    },
    {
      "question": "链表分为________、________、________。",
      "answer": "单链表  双链表  循环链表"
    },
    {
      "question": "分支界限法解空间搜索方式为________。",
      "answer": "广度优先搜索"
    }
  ],
  "判断题": [
    {
      "question": "算法的时间复杂度是指算法执行过程中实际消耗的时间。（）",
      "answer": "错误"
    },
    {
      "question": "冒泡排序在最好情况下（输入数组已有序）的时间复杂度为O(n)。（）",
      "answer": "正确"
    },
    {
      "question": "贪心算法总能得到问题的最优解。（）",
      "answer": "错误"
    },
    {
      "question": "一个问题的时间复杂度为O( )，意味着它的运行时间一定比时间复杂度为O(nlogn)的算法慢。（）",
      "answer": "错误"
    },
    {
      "question": "对于有n个顶点的无向连通图，其最小生成树一定包含n−1条边，且任意删除其中一条边后，图将不再连通。（）",
      "answer": "错误"
    },
    {
      "question": "分治法可以通过将大任务分解为独立的子任务，并在并行环境下同时执行这些子任务，以提高效率。",
      "answer": "正确"
    },
    {
      "question": "哈希表是一种使用哈希函数将关键字映射到存储地址的数据结构。",
      "answer": "正确"
    },
    {
      "question": "heapq.heappop(pqu)：从优先队列pqu中删除堆顶元素并且返回该元素。",
      "answer": "正确"
    },
    {
      "question": "栈具有后进先出的特点。",
      "answer": "正确"
    },
    {
      "question": "列表之间的深复制是通过调用copy模块的deepcopy( )实现的。",
      "answer": "正确"
    },
    {
      "question": "数组在内存中占用连续存储空间，且可以通过下标直接访问任意元素，因此数组支持O(1)时间的插入和删除操作。（ ）",
      "answer": "错误"
    },
    {
      "question": "在双向链表中，删除某个已知节点（非头尾节点）的操作时间复杂度为O(1)（ ）",
      "answer": "正确"
    },
    {
      "question": "二叉排序树（BST）的中序遍历序列一定是有序的。（ ）",
      "answer": "正确"
    },
    {
      "question": "图的深度优先搜索（DFS）和广度优先搜索（BFS）的时间复杂度相同，均为O(V+E)，其中V是顶点数，E是边数。（ ）",
      "answer": "正确"
    },
    {
      "question": "栈是一种后进先出（LIFO）的数据结构，因此栈不能用于实现队列的功能。（ ）",
      "answer": "错误"
    },
    {
      "question": "普通队列是一种先进先出的数据结构，在队尾进队元素，在队头出队元素。（）",
      "answer": "正确"
    },
    {
      "question": "递归调用的次数可以是无限的。（）",
      "answer": "错误"
    },
    {
      "question": "利用子问题的解合并为问题的解，该特征是能否利用分治法求解的关键。（）",
      "answer": "正确"
    },
    {
      "question": "回溯法就是在解空间中采用深度优先搜索方法从根节点出发搜索解。（）",
      "answer": "正确"
    },
    {
      "question": "与回溯法不同，分支限界法不在解空间中搜索问题的解。（）",
      "answer": "错误"
    },
    {
      "question": "动态规划算法通常适用于具有最优子结构的问题，且子问题之间相互独立。（ ）",
      "answer": "错误"
    },
    {
      "question": "贪心算法在每一步都选择局部最优解，因此一定能得到全局最优解。（ ）",
      "answer": "错误"
    },
    {
      "question": "分治法的基本思想是将问题分解为规模更小的子问题，递归求解后再合并结果。（ ）",
      "answer": "正确"
    },
    {
      "question": "回溯算法通过枚举所有可能的解来求解问题，适用于组合优化问题。（ ）",
      "answer": "正确"
    },
    {
      "question": "NP 问题是指可以在多项式时间内验证解的正确性的问题。（ ）",
      "answer": "正确"
    },
    {
      "question": "时间复杂度是指算法执行所需的具体时间，与输入规模无关。（ ）",
      "answer": "错误"
    },
    {
      "question": "空间复杂度仅考虑算法运行时占用的额外存储空间，不包含输入数据本身的存储。（ ）",
      "answer": "正确"
    },
    {
      "question": "贪心算法总能找到全局最优解。（ ）",
      "answer": "错误"
    },
    {
      "question": "冒泡排序在最好情况下（输入序列已有序）的时间复杂度是O(n²)。（ ）",
      "answer": "错误"
    },
    {
      "question": "算法的时间复杂度越低，说明算法的执行效率一定越高（不考虑常数因子和实际硬件环境）。（ ）",
      "answer": "错误"
    },
    {
      "question": "动态规划算法必须满足最优子结构性质和重叠子问题性质。",
      "answer": "正确"
    },
    {
      "question": "回溯法采用深度优先搜索策略遍历解空间树，通过剪枝减少搜索空间。",
      "answer": "正确"
    },
    {
      "question": "在二叉搜索树中查找一个元素的时间复杂度总是 O(log n)",
      "answer": "错误"
    },
    {
      "question": "哈夫曼编码是一种贪心算法，它总是优先合并当前频率最小的两个节点。",
      "answer": "正确"
    },
    {
      "question": "如果一个问题是NP完全问题，则表明目前不可能找到在多项式时间内求解该问题的算法。",
      "answer": "错误"
    },
    {
      "question": "算法可以用不同的语言描述，所以算法等同于程序。",
      "answer": "错误"
    },
    {
      "question": "算法的实现依赖于数据结构的设计，数据结构越简单，算法的效率越高。",
      "answer": "错误"
    },
    {
      "question": "算法的有穷性是指算法程序的运行时间是有限的。",
      "answer": "正确"
    },
    {
      "question": "队列是先进先出，优先队列是按优先级高的出队。",
      "answer": "正确"
    },
    {
      "question": "穷举法算法可以通过优化提高时间性能。",
      "answer": "正确"
    },
    {
      "question": "算法的时间复杂度分析仅需要考虑算法执行的绝对时间长短。（ ）",
      "answer": "错误"
    },
    {
      "question": "Python 中的双端队列（deque）仅能在队首进行元素的插入和删除操作。（ ）",
      "answer": "错误"
    },
    {
      "question": "分治法的核心思想是将一个大问题分解为多个规模较小的子问题，求解子问题后再合并结果。（ ）",
      "answer": "正确"
    },
    {
      "question": "回溯法的搜索过程与图的深度优先遍历的逻辑完全一致，无任何差别。（ ）",
      "answer": "错误"
    },
    {
      "question": "分支限界法在搜索解空间树时，会对每个活节点计算一个界限值，以此判断该节点是否有继续扩展的价值。（ ）",
      "answer": "正确"
    }
  ]
}